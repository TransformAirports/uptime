This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-04T19:09:28.544Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------
User Provided Header:
-----------------------
Files in the /functions folder are Firebase Functions

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
dev/
  firebaseConfig.js
  index.html
  script.js
  styles.css
functions/
  createUser.js
  deleteUser.js
  emailCheck.js
  index.js
  listUsers.js
  updateUptime.js

================================================================
Repository Files
================================================================

================
File: dev/firebaseConfig.js
================
async function loadFirebaseConfig() {
  const response = await fetch('localFirebase.json');
  const config = await response.json();
  // Initialize Firebase with the loaded config
  if (!firebase.apps.length) {
    firebase.initializeApp(config);
  }
  return config;
}

================
File: dev/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EEMW Uptime Dashboard</title>
    <!-- Custom Bootstrap: https://bootswatch.com/simplex/ -->
    <link rel="stylesheet" href="bootstrap.min.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/css/intlTelInput.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
    />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="container-fluid">
      <div id="alert-container" class="container my-3"></div>

      <div
        id="deviceAccordion"
        class="accordion container-fluid"
        style="display: none"
      ></div>

      <!-- Login Form -->
      <div id="login-form" class="my-4" style="display: none">
        <h2>EEMW Uptime Monitoring System Login</h2>
        <div class="mb-3">
          <label for="email" class="form-label">Email address</label>
          <input
            type="email"
            class="form-control"
            id="login-email"
            placeholder="Enter email"
          />
        </div>
        <div class="mb-3">
          <label for="password" class="form-label">Password</label>
          <input
            type="password"
            class="form-control"
            id="login-password"
            placeholder="Password"
          />
        </div>
        <button class="btn btn-primary" id="login-button">Login</button>
        <!-- <button class="btn btn-secondary" id="signup-button">Sign Up</button> -->
      </div>

      <!-- Signup Form -->
      <div id="signup-form" class="my-4" style="display: none">
        <h2>Create EEMW Monitoring Account</h2>
        <div class="mb-3">
          <label for="signup-email" class="form-label">Email address</label>
          <input
            type="email"
            class="form-control"
            id="signup-email"
            placeholder="Enter email"
          />
        </div>
        <div class="mb-3">
          <label for="signup-password" class="form-label">Password</label>
          <input
            type="password"
            class="form-control"
            id="signup-password"
            placeholder="Password"
          />
        </div>
        <div class="mb-3">
          <label for="signup-phone" class="form-label">Phone Number</label>
          <input
            type="tel"
            class="form-control"
            id="signup-phone"
            placeholder="Enter phone number"
          />
        </div>
        <!-- Container for reCAPTCHA verifier -->
        <div id="recaptcha-container"></div>
        <button class="btn btn-primary" id="send-verification-code-button">
          Send Verification Code
        </button>
        <div class="mb-3" id="verification-code-div" style="display: none">
          <label for="verification-code" class="form-label"
            >Verification Code</label
          >
          <input
            type="text"
            class="form-control"
            id="verification-code"
            placeholder="Enter verification code"
          />
        </div>
        <button
          class="btn btn-primary"
          id="create-account-button"
          style="display: none"
        >
          Create Account
        </button>
        <button class="btn btn-secondary" id="back-to-login-button">
          Back to Login
        </button>
      </div>

      <!-- Admin Content (visible after login) -->
      <div
        id="admin-content"
        class="container-fluid my-4"
        style="display: none"
      >
        <button
          class="btn btn-secondary mb-3"
          id="logout-button"
          style="position: absolute; top: 10px; right: 10px"
        >
          Logout
        </button>
        <h2>Admin - Manage Alert Email Addresses</h2>
        <div class="row">
          <div class="col-md-6">
            <h3>DCA</h3>
            <ul id="emailListDCA" class="list-group mb-3"></ul>
            <div class="input-group mb-3">
              <input
                type="email"
                id="newEmailDCA"
                class="form-control"
                placeholder="Add new email for DCA"
                aria-label="Add new email for DCA"
                aria-describedby="addEmailButtonDCA"
              />
              <button
                class="btn btn-primary"
                type="button"
                id="addEmailButtonDCA"
              >
                Add Email
              </button>
            </div>
          </div>
          <div class="col-md-6">
            <h3>IAD</h3>
            <ul id="emailListIAD" class="list-group mb-3"></ul>
            <div class="input-group mb-3">
              <input
                type="email"
                id="newEmailIAD"
                class="form-control"
                placeholder="Add new email for IAD"
                aria-label="Add new email for IAD"
                aria-describedby="addEmailButtonIAD"
              />
              <button
                class="btn btn-primary"
                type="button"
                id="addEmailButtonIAD"
              >
                Add Email
              </button>
            </div>
          </div>
        </div>
        <div class="row">
          <!-- Create User Section -->
          <div class="col-md-6">
            <h3>Create New User</h3>
            <div class="mb-3">
              <label for="new-user-email" class="form-label"
                >Email address</label
              >
              <input
                type="email"
                class="form-control"
                id="new-user-email"
                placeholder="Enter email"
              />
            </div>
            <div class="mb-3">
              <label for="new-user-password" class="form-label">Password</label>
              <input
                type="password"
                class="form-control"
                id="new-user-password"
                placeholder="Password"
              />
            </div>
            <button class="btn btn-primary" id="create-user-button">
              Create User
            </button>
          </div>
          <!-- Delete User Section -->
          <div class="col-md-6">
            <h3>Existing Users</h3>
            <ul id="user-list" class="list-group mb-3"></ul>
          </div>
        </div>
      </div>
    </div>

    <!-- Outage Log Modal -->
    <div
      class="modal fade"
      id="outageLogModal"
      tabindex="-1"
      aria-labelledby="outageLogModalLabel"
      aria-hidden="true"
    >
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="outageLogModalLabel">
              Outage Log for <span id="modalDeviceID"></span>
            </h5>
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="modal"
              aria-label="Close"
            ></button>
          </div>
          <div class="modal-body">
            <ul id="outageLogList" class="list-group"></ul>
          </div>
          <div class="modal-footer">
            <button
              type="button"
              class="btn btn-secondary"
              data-bs-dismiss="modal"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Fixed Footer Navbar -->
    <nav class="navbar fixed-bottom navbar-dark bg-dark">
      <div
        class="container-fluid d-flex justify-content-between align-items-center"
      >
        <a class="navbar-brand" href="#">Uptime Monitor</a>
        <ul class="navbar-nav flex-row">
          <li class="nav-item">
            <a class="nav-link" href="#" id="dca-tab">DCA</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#" id="iad-tab">IAD</a>
          </li>
          <li class="nav-item" id="admin-nav-item" style="display: none">
            <a class="nav-link" href="#" id="admin-tab">Admin</a>
          </li>
          <!-- Logout Link -->
          <li class="nav-item" id="logout-nav-item" style="display: none">
            <a class="nav-link" href="#" id="logout-link">Logout</a>
          </li>
        </ul>
        <span class="navbar-text">
          This application is not supported by the Office of Technology.
        </span>
      </div>
    </nav>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-functions.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/js/intlTelInput.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/libphonenumber-js/1.9.48/libphonenumber-js.min.js"></script>
    <script src="firebaseConfig.js"></script>
    <script src="script.js"></script>
  </body>
</html>

================
File: dev/script.js
================
// script.js

// Initialize necessary variables
let deviceIntervals = {}; // Interval timers for each device (for updating timers)
let currentDeviceStates = {}; // Placeholder for state-tracking (currently unused)
let currentCampus; // Variable to store the current campus (DCA or IAD)
let devicesRef; // Reference to the devices in Firebase
let devicesListener; // Listener for the devices reference
let phoneInputField;
let iti;
let functions;

// Function to load Firebase config from localFirebase.json
function loadFirebaseConfig() {
  return fetch("localFirebase.json") // Fetch the Firebase configuration from localFirebase.json
    .then((response) => response.json()) // Parse the JSON file
    .then((config) => {
      // Initialize Firebase with the loaded config
      firebase.initializeApp(config);
      return config;
    })
    .catch((error) => {
      console.error("Error loading Firebase config:", error);
      throw error; // Re-throw the error after logging it
    });
}

// Function to show/hide content based on selected tab and authentication status
const showTabContent = (tab) => {
  const adminContent = document.getElementById("admin-content");
  const devicesContainer = document.getElementById("deviceAccordion");
  const loginForm = document.getElementById("login-form");
  const signupForm = document.getElementById("signup-form");
  const logoutNavItem = document.getElementById("logout-nav-item");

  const user = firebase.auth().currentUser;

  if (user) {
    // User is authenticated
    loginForm.style.display = "none";
    signupForm.style.display = "none";
    logoutNavItem.style.display = "block";

    if (tab === 'Admin' && window.isAdmin) {
      adminContent.style.display = 'block';
      devicesContainer.style.display = 'none';
      // Load admin content
      loadEmailAddresses();
      loadUserList(); // Load users
    } else {
      adminContent.style.display = "none";
      devicesContainer.style.display = "block";
      // Load devices for the selected campus
      loadDevices();
    }
  } else {
    // User is not authenticated
    loginForm.style.display = "block";
    signupForm.style.display = "none";
    adminContent.style.display = "none";
    devicesContainer.style.display = "none";
    logoutNavItem.style.display = "none";
  }
};

// Declare phoneInputField and iti as global variables if needed elsewhere
let phoneInputField;
let iti;

// Function to start the application
function startApp() {

  // Initialize phoneInputField and intl-tel-input
  phoneInputField = document.getElementById("signup-phone");
  iti = window.intlTelInput(phoneInputField, {
    initialCountry: "us",
    separateDialCode: true,
    utilsScript:
      "https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/17.0.8/js/utils.js",
  });

  // Set the campus based on URL parameter or default to DCA
  currentCampus = getCampusFromURL();
  setActiveTab(currentCampus);

  // Event listeners for campus tab switching
  const dcaTab = document.getElementById("dca-tab");
  const iadTab = document.getElementById("iad-tab");
  const adminTab = document.getElementById("admin-tab");

  if (dcaTab) {
    dcaTab.addEventListener("click", () => {
      currentCampus = "DCA";
      setActiveTab(currentCampus);
    });
  }

  if (iadTab) {
    iadTab.addEventListener("click", () => {
      currentCampus = "IAD";
      setActiveTab(currentCampus);
    });
  }

  if (adminTab) {
    adminTab.addEventListener("click", () => {
      setActiveTab("Admin");
    });
  }

  // Event listeners for adding emails
  const addEmailButtonDCA = document.getElementById("addEmailButtonDCA");
  const addEmailButtonIAD = document.getElementById("addEmailButtonIAD");

  if (addEmailButtonDCA) {
    addEmailButtonDCA.addEventListener("click", () => addEmailAddress("DCA"));
  }

  if (addEmailButtonIAD) {
    addEmailButtonIAD.addEventListener("click", () => addEmailAddress("IAD"));
  }

  // Login Logic
  const loginButton = document.getElementById("login-button");
  if (loginButton) {
    loginButton.addEventListener("click", () => {
      const email = document.getElementById("login-email").value;
      const password = document.getElementById("login-password").value;

      firebase
        .auth()
        .signInWithEmailAndPassword(email, password)
        .then((userCredential) => {
          // User signed in successfully
          console.log("Logged in successfully");
          setActiveTab(currentCampus); // Update the UI after login
        })
        .catch((error) => {
          console.error("Login failed:", error);
          if (error.code === "auth/user-disabled") {
            showAlert(
              "Your account has been disabled. Please contact support.",
              "danger"
            );
          } else {
            showAlert("Login failed: " + error.message, "danger");
          }
        });
    });
  }

  // Logout Logic for the Logout link in the navbar
  const logoutLink = document.getElementById("logout-link");
  if (logoutLink) {
    logoutLink.addEventListener("click", (event) => {
      event.preventDefault(); // Prevent default link behavior
      firebase
        .auth()
        .signOut()
        .then(() => {
          console.log("Logged out successfully");

          // Remove any database listeners
          if (devicesRef && devicesListener) {
            devicesRef.off("value", devicesListener);
          }

          // Update the UI after logout
          setActiveTab(currentCampus);
        })
        .catch((error) => {
          console.error("Logout failed:", error);
          showAlert("Logout failed: " + error.message, "danger");
        });
    });
  }

  // Event listener for the sign-up button
  const signupButton = document.getElementById("signup-button");
  if (signupButton) {
    signupButton.addEventListener("click", () => {
      document.getElementById("login-form").style.display = "none";
      document.getElementById("signup-form").style.display = "block";
    });
  }

  // Event listener for back to login button
  const backToLoginButton = document.getElementById("back-to-login-button");
  if (backToLoginButton) {
    backToLoginButton.addEventListener("click", () => {
      document.getElementById("signup-form").style.display = "none";
      document.getElementById("login-form").style.display = "block";
    });
  }

  // Sign-up Logic
  const createAccountButton = document.getElementById("create-account-button");
  if (createAccountButton) {
    createAccountButton.addEventListener("click", () => {
      const email = document.getElementById("signup-email").value;
      const password = document.getElementById("signup-password").value;
      const verificationCode = document.getElementById("verification-code").value;

      // Client-side check for MWAA email
      if (!email.endsWith("@mwaa.com")) {
        showAlert("Only MWAA email addresses are allowed.", "warning");
        return;
      }

      if (!verificationCode) {
        showAlert(
          "Please enter the verification code sent to your phone.",
          "warning"
        );
        return;
      }

      // Create email/password user
      firebase
        .auth()
        .createUserWithEmailAndPassword(email, password)
        .then((userCredential) => {
          const user = userCredential.user;

          // Create a PhoneAuthCredential with the code
          const credential = firebase.auth.PhoneAuthProvider.credential(
            window.verificationId,
            verificationCode
          );

          // Link the phone number to the user
          user
            .linkWithCredential(credential)
            .then(() => {
              showAlert(
                "Account created and phone number linked successfully.",
                "success"
              );
              // Redirect to login form
              document.getElementById("signup-form").style.display = "none";
              document.getElementById("login-form").style.display = "block";
            })
            .catch((error) => {
              console.error("Error linking phone number:", error);
              showAlert(
                "Error linking phone number: " + error.message,
                "danger"
              );
            });
        })
        .catch((error) => {
          console.error("Account creation failed:", error);
          showAlert("Account creation failed: " + error.message, "danger");
        });
    });
  }

  // Initialize reCAPTCHA verifier
  let recaptchaVerifier;

// Event listener for 'Send Verification Code' button
const sendVerificationCodeButton = document.getElementById(
  "send-verification-code-button"
);
sendVerificationCodeButton.addEventListener("click", () => {
  let phoneNumber = iti.getNumber();

  if (!phoneNumber) {
    showAlert("Please enter a valid phone number.", "warning");
    return;
  }

  // Validate the phone number
  if (!iti.isValidNumber()) {
    showAlert("The phone number entered is not valid.", "warning");
    return;
  }

  // Proceed with phone number verification using phoneNumber
  // Set up reCAPTCHA verifier
  if (!recaptchaVerifier) {
    recaptchaVerifier = new firebase.auth.RecaptchaVerifier(
      "recaptcha-container",
      {
        size: "invisible",
      }
    );
  } else {
    recaptchaVerifier.clear();
    recaptchaVerifier = new firebase.auth.RecaptchaVerifier(
      "recaptcha-container",
      {
        size: "invisible",
      }
    );
  }

  const appVerifier = recaptchaVerifier;

  const phoneProvider = new firebase.auth.PhoneAuthProvider();
  phoneProvider
    .verifyPhoneNumber(phoneNumber, appVerifier)
    .then((verificationId) => {
      window.verificationId = verificationId;
      showAlert("Verification code sent to your phone.", "success");
      document.getElementById("verification-code-div").style.display = "block";
      document.getElementById("create-account-button").style.display = "block";
      sendVerificationCodeButton.style.display = "none";
    })
    .catch((error) => {
      console.error("Error during phone number verification:", error);
      showAlert("Error sending verification code: " + error.message, "danger");
    });
});

  // Monitor authentication state and update UI accordingly
  firebase.auth().onAuthStateChanged((user) => {
    if (user) {
      checkAdminStatus(user.uid).then((isAdmin) => {
        window.isAdmin = isAdmin;
        setActiveTab(currentCampus);
        // Show or hide the Admin tab based on admin status
        toggleAdminTab(isAdmin);
      });
    } else {
      window.isAdmin = false;
      setActiveTab('login');
      toggleAdminTab(false);
    }
  });  
}

function checkAdminStatus(uid) {
  return firebase
    .database()
    .ref(`/admins/${uid}`)
    .once('value')
    .then((snapshot) => {
      return snapshot.exists();
    });
}

function toggleAdminTab(isAdmin) {
  const adminNavItem = document.getElementById('admin-nav-item');
  if (isAdmin) {
    adminNavItem.style.display = 'block';
  } else {
    adminNavItem.style.display = 'none';
  }
}

// Logout Logic for the Logout button in the admin content
const logoutButton = document.getElementById("logout-button");
if (logoutButton) {
  logoutButton.addEventListener("click", () => {
    firebase
      .auth()
      .signOut()
      .then(() => {
        console.log("Logged out successfully");

        // Remove any database listeners
        if (devicesRef && devicesListener) {
          devicesRef.off("value", devicesListener);
        }

        // Update the UI after logout
        setActiveTab(currentCampus);
      })
      .catch((error) => {
        console.error("Logout failed:", error);
        showAlert("Logout failed: " + error.message, "danger");
      });
  });
}

function loadUserList() {
  const listUsers = functions.httpsCallable('listUsers'););
  listUsers()
    .then((result) => {
      const users = result.data.users;
      const userList = document.getElementById('user-list');
      userList.innerHTML = ''; // Clear the list
      users.forEach((user) => {
        const listItem = document.createElement('li');
        listItem.className =
          'list-group-item d-flex justify-content-between align-items-center';
        listItem.textContent = user.email;
        const deleteButton = document.createElement('button');
        deleteButton.className = 'btn btn-danger btn-sm';
        deleteButton.textContent = 'Delete';
        deleteButton.onclick = () => deleteUser(user.uid);
        listItem.appendChild(deleteButton);
        userList.appendChild(listItem);
      });
    })
    .catch((error) => {
      console.error('Error listing users:', error);
      showAlert('Error listing users: ' + error.message, 'danger');
    });
}

function deleteUser(uid) {
  const deleteUserFunction = firebase.functions().httpsCallable('deleteUser');
  deleteUserFunction({ uid })
    .then(() => {
      showAlert('User deleted successfully.', 'success');
      loadUserList();
    })
    .catch((error) => {
      console.error('Error deleting user:', error);
      showAlert('Error deleting user: ' + error.message, 'danger');
    });
}

document.getElementById('create-user-button').addEventListener('click', () => {
  const email = document.getElementById('new-user-email').value;
  const password = document.getElementById('new-user-password').value;

  // Enforce email domain restriction
  const emailDomain = email.substring(email.lastIndexOf('@') + 1).toLowerCase();
  if (emailDomain !== 'mwaa.com') {
    showAlert('Email domain must be mwaa.com.', 'warning');
    return;
  }

  // Call the Cloud Function to create a new user
  const createUser = functions.httpsCallable('createUser');
  createUser({ email, password })
    .then((result) => {
      showAlert('User created successfully.', 'success');
      document.getElementById('new-user-email').value = '';
      document.getElementById('new-user-password').value = '';
      loadUserList();
    })
    .catch((error) => {
      console.error('Error creating user:', error);
      showAlert('Error creating user: ' + error.message, 'danger');
    });
});

// Function to set the active tab and update the URL
const setActiveTab = (tab) => {
  if (tab === 'Admin' && !window.isAdmin) {
    showAlert('Access denied: Admins only.', 'danger');
    return;
  }
  document.querySelectorAll(".nav-link").forEach((link) => {
    link.classList.remove("active");
  });
  const tabElement = document.getElementById(`${tab.toLowerCase()}-tab`);
  if (tabElement) {
    tabElement.classList.add("active");
  }

  history.pushState({}, "", `?campus=${tab}`);

  showTabContent(tab);
};

// Function to load email addresses for both campuses in the admin tab
const loadEmailAddresses = () => {
  const emailListDCA = document.getElementById("emailListDCA");
  const emailListIAD = document.getElementById("emailListIAD");
  emailListDCA.innerHTML = ""; // Clear existing emails for DCA
  emailListIAD.innerHTML = ""; // Clear existing emails for IAD

  const emailsRef = firebase.database().ref(`/alertEmails`);
  emailsRef.once("value", (snapshot) => {
    const emails = snapshot.val();

    if (emails) {
      // Load emails for DCA
      Object.entries(emails.DCA || {}).forEach(([key, email]) => {
        const listItem = createEmailListItem(email, key, "DCA");
        emailListDCA.appendChild(listItem);
      });

      // Load emails for IAD
      Object.entries(emails.IAD || {}).forEach(([key, email]) => {
        const listItem = createEmailListItem(email, key, "IAD");
        emailListIAD.appendChild(listItem);
      });
    }
  });
};

// Function to create a list item for an email address
const createEmailListItem = (email, key, campus) => {
  const listItem = document.createElement("li");
  listItem.className =
    "list-group-item d-flex justify-content-between align-items-center";
  listItem.textContent = email;

  const removeButton = document.createElement("button");
  removeButton.className = "btn btn-danger btn-sm";
  removeButton.textContent = "Remove";
  removeButton.onclick = () => removeEmail(key, campus);

  listItem.appendChild(removeButton);
  return listItem;
};

// Function to add a new email address based on campus
const addEmailAddress = (campus) => {
  const newEmailInput = document.getElementById(`newEmail${campus}`);
  const newEmail = newEmailInput.value.trim();
  if (newEmail) {
    const emailsRef = firebase.database().ref(`/alertEmails/${campus}`);
    emailsRef.push(newEmail, () => {
      newEmailInput.value = ""; // Clear input field
      loadEmailAddresses(); // Refresh email list
    });
  } else {
    showAlert("Please enter a valid email address.", "warning");
  }
};

// Function to remove an email address based on campus
const removeEmail = (emailKey, campus) => {
  const emailsRef = firebase
    .database()
    .ref(`/alertEmails/${campus}/${emailKey}`);
  emailsRef.remove(() => {
    loadEmailAddresses(); // Refresh email list
  });
};

// Attach event listeners to each device card for showing outage logs
const attachCardEventListeners = () => {
  document.querySelectorAll(".device-card").forEach((card) => {
    card.addEventListener("click", (event) => {
      const deviceID = event.currentTarget.getAttribute("data-id");
      showOutageLogs(deviceID);
    });
  });
};

// Load and display devices for the selected campus (DCA or IAD)
const loadDevices = () => {
  const user = firebase.auth().currentUser;
  if (!user) {
    console.error("User not authenticated, cannot load devices.");
    return;
  }

  const db = firebase.database();

  // Remove any existing listener
  if (devicesRef && devicesListener) {
    devicesRef.off("value", devicesListener);
  }

  devicesRef = db.ref(`/devices/${currentCampus}`);

  devicesListener = devicesRef.on(
    "value",
    (snapshot) => {
      const devices = snapshot.val();
      const devicesContainer = document.getElementById("deviceAccordion");
      devicesContainer.innerHTML = ""; // Clear existing devices

      const deviceTypes = {
        elevator: "Elevators",
        escalator: "Escalators",
        sidewalk: "Moving Sidewalks",
      };

      const groupedDevices = {
        elevator: [],
        escalator: [],
        sidewalk: [],
      };

      // Group devices by type
      for (let type in devices) {
        type = type.toLowerCase(); // Normalize type to lowercase
        if (!groupedDevices[type]) continue; // Skip if type is not recognized
        for (const deviceID in devices[type]) {
          const device = devices[type][deviceID];
          groupedDevices[type].push({ type, deviceID, ...device });
        }
      }

      // Display devices by type using accordion
      for (const type in groupedDevices) {
        if (groupedDevices[type].length > 0) {
          // Sort devices so that online devices come first
          groupedDevices[type].sort((a, b) => {
            const getStatusValue = (device) => {
              if (!device.monitored) return 2; // Unmonitored devices last
              if (device.power && !device.alarm) return 0; // Online devices first
              return 1; // Offline devices in between
            };

            return getStatusValue(a) - getStatusValue(b);
          });

          const accordionItem = document.createElement("div");
          accordionItem.classList.add("accordion-item");
          accordionItem.setAttribute("data-type", type);

          const headingId = `heading-${type}`;
          const collapseId = `collapse-${type}`;
          const isExpanded = true; // Open by default
          const showClass = isExpanded ? "show" : "";

          // Count online devices
          const onlineCount = groupedDevices[type].filter(
            (device) => device.monitored && device.power && !device.alarm
          ).length;
          const totalCount = groupedDevices[type].length;

          // Create accordion header and body
          accordionItem.innerHTML = `
            <h2 class="accordion-header" id="${headingId}">
              <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="${isExpanded}" aria-controls="${collapseId}">
                ${deviceTypes[type]}<span class="lead"> (${onlineCount} of ${totalCount} online)</span>
              </button>
            </h2>
            <div id="${collapseId}" class="accordion-collapse collapse ${showClass}" aria-labelledby="${headingId}" data-bs-parent="#deviceAccordion">
              <div class="accordion-body">
                <div class="row"></div>
              </div>
            </div>
          `;

          devicesContainer.appendChild(accordionItem);

          const rowDiv = accordionItem.querySelector(".row");

          // Create a card for each device and display its status
          groupedDevices[type].forEach((device) => {
            const deviceID = device.deviceID;
            const isMonitored = device.monitored;
            const deviceStatus =
              isMonitored && device.power && !device.alarm
                ? "online"
                : "offline";
            const timeLabel =
              deviceStatus === "online" ? "Time Online" : "Time Offline";
            const lastStatusChangeTimestamp = device.lastStatusChangeTimestamp;
            const lastStatusCheckTimestamp = device.last_statuscheck_timestamp;

            // Create device card
            const deviceDiv = document.createElement("div");
            deviceDiv.classList.add("device-card");
            deviceDiv.setAttribute("data-id", deviceID);

            // Prepare extra info HTML if device is monitored
            let extraInfoHTML = "";
            if (isMonitored) {
              extraInfoHTML = `
                <p class="card-text extra-info">
                  <small class="text-muted">Hours Uptime this Month:</small> <span id="uptime-hours-${deviceID}">${
                device.currentMonthUptime
                  ? device.currentMonthUptime.uptimeHours
                  : "N/A"
              }</span><br>
                  <small class="text-muted">% Uptime this Month:</small> <span id="uptime-percentage-${deviceID}">${
                device.currentMonthUptime
                  ? device.currentMonthUptime.uptimePercentage
                  : "N/A"
              }</span>%<br>
                  <small class="text-muted" id="last-reading-${deviceID}">Last sensor reading: ${new Date(
                lastStatusCheckTimestamp * 1000
              ).toLocaleString()}</small>
                </p>
              `;
            }

            // Build the card HTML
            deviceDiv.innerHTML = `
              <div class="card device ${
                isMonitored ? deviceStatus : "unmonitored"
              }">
                <div class="card-body">
                  <h4 class="card-title">${deviceID}</h4>
                  <p class="card-text small text-muted">${
                    device.location || "Location unknown"
                  }</p>
                  <p class="card-text">
                    <strong>Power:</strong> <span class="power-indicator" style="color: ${
                      isMonitored ? (device.power ? "green" : "red") : "grey"
                    };"><i class="fas fa-circle"></i></span><br>
                    <strong>Alarm:</strong> <span class="alarm-indicator" style="color: ${
                      isMonitored ? (device.alarm ? "red" : "green") : "grey"
                    };"><i class="fas fa-circle"></i></span><br>
                    <strong>${timeLabel}:</strong> <span id="timer-${deviceID}">${
              isMonitored ? "" : "-"
            }</span>
                  </p>
                  ${extraInfoHTML}
                </div>
              </div>
            `;

            // Append the device card to the row
            rowDiv.appendChild(deviceDiv);

            // Set up interval to update timer and status
            if (isMonitored) {
              if (deviceIntervals[deviceID]) {
                clearInterval(deviceIntervals[deviceID]);
              }

              deviceIntervals[deviceID] = setInterval(() => {
                const now = Math.floor(Date.now() / 1000);
                const uptime = now - lastStatusChangeTimestamp;
                const days = Math.floor(uptime / (24 * 3600));
                const hours = Math.floor((uptime % (24 * 3600)) / 3600);
                const minutes = Math.floor((uptime % 3600) / 60);
                const seconds = uptime % 60;

                const timerElement = deviceDiv.querySelector(
                  `#timer-${deviceID}`
                );
                if (timerElement) {
                  timerElement.innerText = `${days}d ${hours}h ${minutes}m ${seconds}s`;
                }

                // Update power and alarm indicators
                const powerIndicator =
                  deviceDiv.querySelector(".power-indicator");
                const alarmIndicator =
                  deviceDiv.querySelector(".alarm-indicator");

                powerIndicator.style.color = device.power ? "green" : "red";
                alarmIndicator.style.color = device.alarm ? "red" : "green";

                // Update last sensor reading
                const lastReadingElement = deviceDiv.querySelector(
                  `#last-reading-${deviceID}`
                );
                if (lastReadingElement) {
                  lastReadingElement.innerText = `Last sensor reading: ${new Date(
                    lastStatusCheckTimestamp * 1000
                  ).toLocaleString()}`;
                }

                // Highlight card if sensor is offline (no data for over 90 seconds)
                const cardElement = deviceDiv.querySelector(".card");
                if (now - lastStatusCheckTimestamp > 90) {
                  cardElement.classList.add("sensor-offline-box");
                } else {
                  cardElement.classList.remove("sensor-offline-box");
                }
              }, 1000);
            }
          });
        }
      }

      // Attach event listeners to the device cards for showing outage logs
      attachCardEventListeners();
    },
    (error) => {
      console.error("Error loading devices:", error);
      if (error.code === "PERMISSION_DENIED") {
        showAlert("You do not have permission to access this data.", "danger");
        firebase.auth().signOut(); // Optionally sign out the user
      }
    }
  );
};

// Function to show outage logs in a modal
const showOutageLogs = (deviceID) => {
  const outageLogList = document.getElementById("outageLogList");
  const modalDeviceID = document.getElementById("modalDeviceID");

  // Clear previous logs
  outageLogList.innerHTML = "";
  modalDeviceID.textContent = deviceID;

  // Reference to the outage logs in Firebase
  const outageLogsRef = firebase
    .database()
    .ref(`/outageLogs/${currentCampus}/elevator/${deviceID}/outages`)
    .limitToLast(10);
  outageLogsRef.once("value", (snapshot) => {
    const outages = snapshot.val();

    if (outages) {
      // Iterate over each outage and display the details
      Object.entries(outages).forEach(([key, outage]) => {
        const start = new Date(outage.start * 1000).toLocaleString();
        const end = outage.end
          ? new Date(outage.end * 1000).toLocaleString()
          : "Ongoing";
        const duration = outage.end
          ? outage.end - outage.start
          : Math.floor(Date.now() / 1000) - outage.start;
        const hours = Math.floor(duration / 3600);
        const minutes = Math.floor((duration % 3600) / 60);
        const seconds = duration % 60;

        const listItem = document.createElement("li");
        listItem.className = "list-group-item";
        listItem.innerHTML = `<strong>Start:</strong> ${start} <br> 
                                <strong>End:</strong> ${end} <br> 
                                <strong>Duration:</strong> ${hours}h ${minutes}m ${seconds}s`;

        outageLogList.appendChild(listItem);
      });
    } else {
      // No outages recorded
      const listItem = document.createElement("li");
      listItem.className = "list-group-item";
      listItem.textContent = "No recorded outages.";
      outageLogList.appendChild(listItem);
    }

    // Show the modal
    const outageLogModal = new bootstrap.Modal(
      document.getElementById("outageLogModal")
    );
    outageLogModal.show();
  });
};

// Function to get the campus from the URL parameters
const getCampusFromURL = () => {
  const params = new URLSearchParams(window.location.search);
  return params.get("campus") || "DCA"; // Default to DCA if no campus is specified
};

// Function to show Bootstrap alerts
function showAlert(message, type = "info") {
  const alertContainer = document.getElementById("alert-container");
  const alertDiv = document.createElement("div");
  alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
  alertDiv.role = "alert";
  alertDiv.innerHTML = `
    ${message}
    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
  `;
  alertContainer.appendChild(alertDiv);

  // Automatically remove the alert after 5 seconds
  setTimeout(() => {
    alertDiv.classList.remove("show");
    alertDiv.classList.add("hide");
    alertDiv.addEventListener("transitionend", () => alertDiv.remove());
  }, 5000);
}

// Ensure the DOM is fully loaded before executing any scripts
document.addEventListener("DOMContentLoaded", function () {
  // Ensure the Firebase config is loaded and initialized first
  loadFirebaseConfig()
    .then(() => {
      console.log("Firebase config loaded and initialized.");

      // Initialize Firebase Functions
      functions = firebase.functions();

      startApp(); // Start the application
    })
    .catch((err) => {
      console.error("Failed to initialize Firebase:", err);
    });
});

================
File: dev/styles.css
================
/* Global Styles */
body {
  font-family: Arial, sans-serif;
}

/* Navbar Styles */
.navbar-nav {
  display: flex;
  flex-direction: row;
}

.navbar-nav .nav-item {
  margin-right: 20px; /* Add spacing between nav items */
}

.navbar-nav .nav-link.active {
  font-weight: bold;
  color: white;
  border-radius: 0.25rem;
}

.navbar-brand {
  padding-left: 15px;
  padding-right: 15px;
}

/* Device Card Styles */
.device-card {
  margin: 5px; /* Margin between cards */
  padding: 5px; /* Padding inside the card */
  border: 1px solid #ccc;
  border-radius: 5px;
}

.device.online {
  background-color: #d4edda;
}

.device.offline {
  background-color: #f8d7da;
}

.device.unmonitored {
  background-color: #e9ecef; /* Grey background for unmonitored devices */
}

.sensor-offline-box {
  border: 2px solid #ffc107; /* Yellow border for sensor offline */
}

/* Status Light Styles */
.device .status-light,
.sensor-status {
  display: inline-block;
  width: 15px;
  height: 15px;
  border-radius: 50%;
}

.device .status-light {
  margin-right: 5px;
}

.sensor-status {
  margin-left: 5px;
}

.status-light.on,
.sensor-online {
  background-color: green !important;
}

.status-light.off,
.sensor-offline {
  background-color: red !important;
}

/* Sensor Status Container */
.sensor-status-container {
  display: flex;
  align-items: center;
  justify-content: flex-end; /* Right align the sensor status */
}

/* Card Styles */
.card {
  height: 100%; /* Ensure that all cards have the same height */
}

.card.unmonitored {
  padding: 5px;
  margin: 5px;
}

.card.unmonitored .card-body {
  padding: 10px;
}

/* Device Type Header */
.device-type {
  margin-bottom: 10px;
}

.device-type h2 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

/* Device Card Container Styles */
.device-type .row,
.accordion-body .row {
  display: flex;
  flex-wrap: wrap;
  margin: -5px; /* Negative margin to offset card padding/margin */
}

.device-type .device-card,
.accordion-body .device-card {
  flex: 1 1 calc(16.66% - 10px); /* Default flex basis for 6 cards per row */
  max-width: calc(16.66% - 10px);
}

/* Media Queries for Responsiveness */
@media (max-width: 767px) {
  .device-type .device-card,
  .accordion-body .device-card {
    flex: 0 1 100%; /* Full width for mobile */
    max-width: 100%;
  }
}

@media (min-width: 768px) and (max-width: 991px) {
  .device-type .device-card,
  .accordion-body .device-card {
    flex: 0 1 calc(33.33% - 10px); /* Adjust width for tablet-sized screens */
    max-width: calc(33.33% - 10px);
  }
}

@media (min-width: 992px) and (max-width: 3839px) {
  .device-type .device-card,
  .accordion-body .device-card {
    flex: 0 1 calc(16.66% - 10px); /* Standard width for six cards per row */
    max-width: calc(16.66% - 10px);
  }
}

@media (min-width: 3840px) {
  .device-type .device-card,
  .accordion-body .device-card {
    flex: 0 1 calc(8.33% - 10px); /* Adjust to fit 12 cards per row on 4K displays */
    max-width: calc(8.33% - 10px);
  }
}

#alert-container {
  position: fixed;
  top: 60px; /* Adjust based on your navbar height */
  right: 20px;
  z-index: 1050;
  width: auto;
  max-width: 300px;
}

================
File: functions/createUser.js
================
// createUser.js

const functions = require('firebase-functions');
const admin = require('firebase-admin');

// Function to create a new user
exports.createUser = functions.https.onCall(async (data, context) => {
  // Authentication check
  if (!context.auth) {
    throw new functions.https.HttpsError(
      'unauthenticated',
      'Request had invalid credentials.'
    );
  }

  const uid = context.auth.uid;

  // Check if requester is an admin
  const adminSnapshot = await admin.database().ref(`/admins/${uid}`).once('value');
  if (!adminSnapshot.exists()) {
    throw new functions.https.HttpsError(
      'permission-denied',
      'Only admins can create new users.'
    );
  }

  const { email, password } = data;

  // Enforce email domain restriction
  const emailDomain = email.substring(email.lastIndexOf('@') + 1).toLowerCase();
  if (emailDomain !== 'mwaa.com') {
    throw new functions.https.HttpsError(
      'invalid-argument',
      'Email domain must be mwaa.com.'
    );
  }

  try {
    // Create the user
    const userRecord = await admin.auth().createUser({ email, password });

    // Optionally, send a welcome email using Postmark
    // Note: Ensure postmarkClient is initialized and configured

    /*
    const postmark = require('postmark');
    const postmarkApiKey = functions.config().postmark.api_key;
    const postmarkClient = new postmark.ServerClient(postmarkApiKey);

    await postmarkClient.sendEmail({
      From: 'StratOps Uptime <uptime@transformairports.com>',
      To: email,
      Subject: 'Welcome to EEMW Uptime Dashboard',
      TextBody: `Hello,

    Your account has been created by an administrator.

    Best regards,
    StratOps Uptime Team`,
    });
    */

    return { uid: userRecord.uid };
  } catch (error) {
    console.error('Error creating new user:', error);
    throw new functions.https.HttpsError(
      'internal',
      'Error creating new user.'
    );
  }
});

================
File: functions/deleteUser.js
================
// deleteUser.js

const functions = require('firebase-functions');
const admin = require('firebase-admin');

// Function to delete a user
exports.deleteUser = functions.https.onCall(async (data, context) => {
  // Authentication check
  if (!context.auth) {
    throw new functions.https.HttpsError(
      'unauthenticated',
      'Request had invalid credentials.'
    );
  }

  const uid = context.auth.uid;

  // Check if requester is an admin
  const adminSnapshot = await admin.database().ref(`/admins/${uid}`).once('value');
  if (!adminSnapshot.exists()) {
    throw new functions.https.HttpsError(
      'permission-denied',
      'Only admins can delete users.'
    );
  }

  const { uid: targetUid } = data;

  if (!targetUid) {
    throw new functions.https.HttpsError(
      'invalid-argument',
      'Target UID is required.'
    );
  }

  try {
    // Delete the user
    await admin.auth().deleteUser(targetUid);

    // Optionally, remove user data from database
    // For example:
    // await admin.database().ref(`/users/${targetUid}`).remove();

    return { success: true };
  } catch (error) {
    console.error('Error deleting user:', error);
    throw new functions.https.HttpsError(
      'internal',
      'Error deleting user.'
    );
  }
});

================
File: functions/emailCheck.js
================
// emailCheck.js

const functions = require('firebase-functions');
const admin = require('firebase-admin');
const postmark = require('postmark');

// Initialize Firebase Admin if not already initialized
if (!admin.apps.length) {
  admin.initializeApp();
}

// Get Postmark API key from Firebase functions config
const postmarkApiKey = functions.config().postmark.api_key;

// Create a Postmark client instance
const postmarkClient = new postmark.ServerClient(postmarkApiKey);

// Email addresses to CC
const ccEmails = ['christian.kessler@mwaa.com', 'patrick.skelton@mwaa.com', 'me@cgk.io', 'pskelton0330@gmail.com'];

exports.restrictEmailDomain = functions.auth.user().onCreate(async (user) => {
  const email = user.email || '';
  const emailDomain = email.substring(email.lastIndexOf('@') + 1).toLowerCase();

  if (emailDomain !== 'mwaa.com') {
    // Optionally delete the user or keep them disabled
    try {
      await admin.auth().deleteUser(user.uid);
      console.log('Deleted user with email:', email);

      // Send notification email
      await postmarkClient.sendEmail({
        From: 'StratOps Uptime <uptime@transformairports.com>',
        To: email,
        Cc: ccEmails.join(', '),
        Subject: 'Account Registration Failed - Unauthorized Email Domain',
        TextBody: `Hello,

Your account registration failed because it does not use an authorized email domain (mwaa.com).

If you believe this is an error, please contact support.

Best regards,
StratOps Uptime Team`,
      });
      console.log('Notification email sent to:', email);
    } catch (error) {
      console.error('Error deleting user or sending email:', error);
    }
    return null;
  }

  // Optionally send a welcome email without verification link
  try {
    await postmarkClient.sendEmail({
      From: 'StratOps Uptime <uptime@transformairports.com>',
      To: email,
      Cc: ccEmails.join(', '),
      Subject: 'Welcome to EEMW Uptime Dashboard',
      TextBody: `Hello,

Welcome to the EEMW Uptime Dashboard. Your account has been successfully created.

Best regards,
StratOps Innovation Team`,
    });

    console.log('Welcome email sent to:', email);
  } catch (error) {
    console.error('Error sending welcome email:', error);
  }

  return null;
});

================
File: functions/index.js
================
// index.js

const functions = require('firebase-functions');
const admin = require('firebase-admin');

// Initialize Firebase Admin SDK only once
admin.initializeApp();

// Export functions from other files
exports.updateUptime = require('./updateUptime').updateUptime;
exports.calculateUptime = require('./updateUptime').calculateUptime;
exports.restrictEmailDomain = require('./emailCheck').restrictEmailDomain;
exports.createUser = require('./createUser').createUser;
exports.deleteUser = require('./deleteUser').deleteUser;
exports.listUsers = require('./listUsers').listUsers;

================
File: functions/listUsers.js
================
// listUsers.js

const functions = require('firebase-functions');
const admin = require('firebase-admin');

// Function to list users
exports.listUsers = functions.https.onCall(async (data, context) => {
  // Authentication check
  if (!context.auth) {
    throw new functions.https.HttpsError(
      'unauthenticated',
      'Request had invalid credentials.'
    );
  }

  const uid = context.auth.uid;

  // Check if requester is an admin
  const adminSnapshot = await admin.database().ref(`/admins/${uid}`).once('value');
  if (!adminSnapshot.exists()) {
    throw new functions.https.HttpsError(
      'permission-denied',
      'Only admins can list users.'
    );
  }

  try {
    const listUsersResult = await admin.auth().listUsers(1000); // Adjust as needed

    const users = listUsersResult.users.map((userRecord) => ({
      uid: userRecord.uid,
      email: userRecord.email,
    }));

    return { users };
  } catch (error) {
    console.error('Error listing users:', error);
    throw new functions.https.HttpsError(
      'internal',
      'Error listing users.'
    );
  }
});

================
File: functions/updateUptime.js
================
// updateUptime.js

const functions = require('firebase-functions');
const admin = require('firebase-admin');
const postmark = require('postmark');
const { DateTime } = require('luxon'); // Import Luxon for time zone management

// Get Postmark API key from Firebase functions config
const postmarkApiKey = functions.config().postmark.api_key;

// Create a Postmark client instance
const postmarkClient = new postmark.ServerClient(postmarkApiKey);

// Define a 6-hour (21600 seconds) interval for email notifications
const EMAIL_INTERVAL_SECONDS = 21600;

/**
 * Sends an email notification using the Postmark Node.js SDK.
 * @param {string} deviceID - The ID of the device that went offline.
 * @param {string} campus - The campus where the device is located (e.g., IAD, DCA).
 * @param {string} type - The type of device (Elevator, Escalator, Moving Walkway).
 * @param {number} timestamp - The timestamp when the device went offline.
 */
async function sendOutageEmail(deviceID, campus, type, timestamp) {
  try {
    // Retrieve the list of email addresses for the specified campus
    const emailSnapshot = await admin.database().ref(`/alertEmails/${campus}`).once('value');
    const emails = emailSnapshot.val();
    
    if (!emails) {
      console.log('No emails found for campus:', campus);
      return;
    }

    // Join the email addresses into a comma-separated string
    const toEmails = Object.values(emails).join(', ');

    // Convert timestamp to New York/EST time
    const estTime = DateTime.fromSeconds(timestamp).setZone('America/New_York').toLocaleString(DateTime.DATETIME_FULL);

    // Prepare the subject and body of the email
    const subject = `${type.charAt(0).toUpperCase() + type.slice(1)} Outage (${deviceID})`;
    const body = `${deviceID} was reported as being offline on ${estTime}.`;

    // Send the email using Postmark SDK
    await postmarkClient.sendEmail({
      From: 'StratOps Uptime <uptime@transformairports.com>',
      To: toEmails,
      Subject: subject,
      TextBody: body
    });

    console.log('Outage email sent for device:', deviceID);
  } catch (error) {
    console.error('Error sending outage email:', error);
  }
}

// Function to update device uptime
const updateUptime = functions.https.onRequest(async (req, res) => {
  if (req.method !== 'POST') {
    return res.status(405).send('Method Not Allowed');
  }

  const { deviceID, campus, type, power, alarm } = req.body;

  // Validate the request body
  if (!deviceID || !campus || !type || typeof power !== 'boolean' || typeof alarm !== 'boolean') {
    return res.status(400).send('Missing or incorrect required parameters');
  }

  const deviceRef = admin.database().ref(`/devices/${campus}/${type}/${deviceID}`);
  const outageLogsRef = admin.database().ref(`/outageLogs/${campus}/${type}/${deviceID}/outages`);
  const emailLogRef = admin.database().ref(`/emailLogs/${campus}/${type}/${deviceID}`);

  try {
    // Get the current data of the device from Firebase
    const snapshot = await deviceRef.once('value');
    const currentData = snapshot.val();

    // Get the current timestamp in seconds
    const now = Math.floor(Date.now() / 1000);
    let updates = {
      last_statuscheck_timestamp: now,
    };

    let triggerEmail = false;

    if (currentData) {
      // Check if there was a change in the power or alarm status
      if (currentData.power !== power || currentData.alarm !== alarm) {
        updates.power = power;
        updates.alarm = alarm;
        updates.lastStatusChangeTimestamp = now;

        // If the device goes offline (power is false or alarm is true), log the outage and prepare to send an email
        if (!power || alarm) {
          triggerEmail = true;
          const newOutageRef = outageLogsRef.push();
          await newOutageRef.set({
            start: now,
            end: null
          });
        } else {
          // If the device comes back online, mark the ongoing outage as ended
          const ongoingOutageQuery = outageLogsRef.orderByChild('end').equalTo(null);
          const ongoingOutageSnapshot = await ongoingOutageQuery.once('value');
          ongoingOutageSnapshot.forEach(outageSnapshot => {
            outageSnapshot.ref.update({ end: now });
          });
        }
      } else {
        // Update last_statuscheck_timestamp even if power and alarm haven't changed
        updates.power = power;
        updates.alarm = alarm;
      }
    } else {
      // If the device does not exist in Firebase, create a new entry
      updates = {
        power,
        alarm,
        last_statuscheck_timestamp: now,
        lastStatusChangeTimestamp: now,
      };

      // If the device is offline during its first entry, log the outage and prepare to send an email
      if (!power || alarm) {
        triggerEmail = true;
        const newOutageRef = outageLogsRef.push();
        await newOutageRef.set({
          start: now,
          end: null
        });
      }
    }

    // Update the device's status in Firebase
    await deviceRef.update(updates);

    // Check if an email should be sent
    if (triggerEmail) {
      // Retrieve the timestamp of the last sent email from Firebase
      const emailLogSnapshot = await emailLogRef.once('value');
      const lastEmailTimestamp = emailLogSnapshot.val();

      // Only send an email if the last one was sent more than 6 hours ago
      if (!lastEmailTimestamp || (now - lastEmailTimestamp > EMAIL_INTERVAL_SECONDS)) {
        setTimeout(async () => {
          await sendOutageEmail(deviceID, campus, type, now);
          // Log the timestamp of the sent email
          await emailLogRef.set(now);
        }, 30000); // 30 seconds delay
      } else {
        console.log(`Email not sent for ${deviceID} due to 6-hour cooldown period.`);
      }
    }

    res.status(200).send('Device status updated successfully');
  } catch (error) {
    console.error('Error updating device status:', error);
    res.status(500).send('Internal Server Error');
  }
});

// Function to calculate and update uptime for all devices
const calculateUptime = functions.pubsub.topic("calculate-uptime").onPublish(async (message) => {
  const now = new Date();
  const month = now.getMonth() + 1;
  const year = now.getFullYear();
  const startOfMonth = new Date(year, month - 1, 1).getTime() / 1000;
  const currentTime = Math.floor(now.getTime() / 1000);
  const totalSecondsInMonth = currentTime - startOfMonth;
  const totalHoursInMonth = totalSecondsInMonth / 3600;

  console.log(`Calculating uptime for month: ${month}, year: ${year}`);
  console.log(`Start of month: ${startOfMonth}, Current time: ${currentTime}`);
  console.log(`Total hours in month so far: ${totalHoursInMonth}`);

  const devicesSnapshot = await admin.database().ref('/devices').once('value');
  const devices = devicesSnapshot.val();

  for (const campus in devices) {
    for (const type in devices[campus]) {
      for (const deviceID in devices[campus][type]) {
        console.log(`Processing device: ${deviceID} in campus: ${campus}, type: ${type}`);
        
        const outageLogsRef = admin.database().ref(`/outageLogs/${campus}/${type}/${deviceID}/outages`);
        const outageLogsSnapshot = await outageLogsRef.once('value');

        let totalOutageTime = 0;

        outageLogsSnapshot.forEach(outageSnapshot => {
          const outage = outageSnapshot.val();
          const outageStart = Math.max(outage.start, startOfMonth);
          const outageEnd = outage.end === null ? currentTime : Math.min(outage.end, currentTime);
          console.log(`Evaluating outage: start=${outage.start}, end=${outage.end}, adjustedStart=${outageStart}, adjustedEnd=${outageEnd}`);
          if (outageEnd >= outageStart) {
            const outageDuration = outageEnd - outageStart;
            totalOutageTime += outageDuration;
            console.log(`Outage duration: ${outageDuration} seconds, Total outage time so far: ${totalOutageTime} seconds`);
          } else {
            console.log(`Invalid outage duration for outage start: ${outage.start}, end: ${outage.end}`);
          }
        });

        const totalOutageHours = totalOutageTime / 3600;
        const uptimeHours = totalHoursInMonth - totalOutageHours;
        const uptimePercentage = (uptimeHours / totalHoursInMonth) * 100;

        console.log(`Total outage hours: ${totalOutageHours}, Uptime hours: ${uptimeHours}, Uptime percentage: ${uptimePercentage}`);

        const updates = {
          currentMonthUptime: {
            totalHours: parseFloat(totalHoursInMonth.toFixed(2)),
            totalOfflineHours: parseFloat(totalOutageHours.toFixed(2)),
            uptimeHours: parseFloat(uptimeHours.toFixed(2)),
            uptimePercentage: parseFloat(uptimePercentage.toFixed(2))
          }
        };

        const deviceRef = admin.database().ref(`/devices/${campus}/${type}/${deviceID}`);
        await deviceRef.update(updates);

        const uptimeRef = admin.database().ref(`/uptimeLogs/${campus}/${type}/${deviceID}/${year}-${month}`);
        await uptimeRef.set({
          totalHours: parseFloat(totalHoursInMonth.toFixed(2)),
          totalOfflineHours: parseFloat(totalOutageHours.toFixed(2)),
          uptimeHours: parseFloat(uptimeHours.toFixed(2)),
          uptimePercentage: parseFloat(uptimePercentage.toFixed(2)),
          calculatedAt: currentTime
        });
      }
    }
  }

  return null;
});

// Export the functions
module.exports = {
  updateUptime,
  calculateUptime
};
